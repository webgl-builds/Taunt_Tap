<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Unity WebGL Player | Taunt_Build_1</title>
    <link rel="shortcut icon" href="TemplateData/favicon.ico" />
    <link rel="stylesheet" href="TemplateData/style.css" />
    <link rel="manifest" href="manifest.webmanifest" />
  </head>

  <body>
    <div id="unity-container">
      <canvas id="unity-canvas" width="960" height="600" tabindex="-1"></canvas>
      <div id="unity-loading-bar">
        <div id="unity-logo"></div>
        <div id="unity-progress-bar-empty">
          <div id="unity-progress-bar-full"></div>
        </div>
      </div>
      <div id="unity-warning"></div>
    </div>

    <script>
      var unityInstance = null;

      const build2URL = "https://webgl-builds.github.io/SpearOnNear/";
      const build2UnityCacheKey = "Spear-Spear On Near-3.2"; // ðŸ‘ˆ replace with key from build2 ServiceWorker.js

      const contentToCache = [
        "Build/tt.loader.js",
        "Build/tt.framework.js.unityweb",
        "Build/tt.data.unityweb",
        "Build/tt.wasm.unityweb",
        "TemplateData/style.css",
      ];

      // dynamically create full URLs
      const build2Files = contentToCache.map((path) => build2URL + path);

      let loadedBytes = [];
      let totalBytes = [];
      let completedFiles = 0;

      function safeSendMessage(goName, methodName, param) {
        if (typeof SendMessage === "function") {
          SendMessage(goName, methodName, param);
        }
      }

      function initBuild1() {
        console.log("ðŸŽ® Init build1: launching tap game + downloading build2");

        var container = document.querySelector("#unity-container");
        var canvas = document.querySelector("#unity-canvas");
        var loadingBar = document.querySelector("#unity-loading-bar");
        var progressBarFull = document.querySelector(
          "#unity-progress-bar-full"
        );

        var buildUrl = "Build";
        var loaderUrl = buildUrl + "/Taunt_Tap.loader.js";
        var config = {
          dataUrl: buildUrl + "/Taunt_Tap.data",
          frameworkUrl: buildUrl + "/Taunt_Tap.framework.js",
          codeUrl: buildUrl + "/Taunt_Tap.wasm",
          streamingAssetsUrl: "StreamingAssets",
          companyName: "DefaultCompany",
          productName: "Taunt_Build_1",
          productVersion: "0.1.1",
        };

        loadingBar.style.display = "block";

        var script = document.createElement("script");
        script.src = loaderUrl;
        script.onload = () => {
          createUnityInstance(canvas, config, (progress) => {
            progressBarFull.style.width = 100 * progress + "%";
          })
            .then((instance) => {
              unityInstance = instance;
              window.SendMessage = unityInstance.SendMessage;
              console.log("âœ… Unity instance: " + typeof unityInstance);
              waitForUnityAndStart();
              loadingBar.style.display = "none";
            })
            .catch((message) => {
              alert(message);
            });
        };
        document.body.appendChild(script);
      }

      function waitForUnityAndStart() {
        const checkReady = setInterval(() => {
          if (
            typeof unityInstance !== "undefined" &&
            unityInstance.Module &&
            typeof SendMessage === "function"
          ) {
            console.log("âœ… Unity instance ready. Starting build2 download.");
            downloadAndCacheBuild2();
            clearInterval(checkReady);
          } else {
            console.log("â³ Waiting for Unity instance...");
          }
        }, 2000);
      }

      function downloadAndCacheBuild2() {
        completedFiles = 0;
        let loadedBytes = new Array(build2Files.length).fill(0);
        let totalBytes = new Array(build2Files.length).fill(1);

        build2Files.forEach((url, idx) => {
          fetch(url)
            .then((response) => {
              if (!response.ok) throw new Error(`Failed to fetch ${url}`);

              const contentLength = response.headers.get("Content-Length");
              if (contentLength) totalBytes[idx] = parseInt(contentLength);

              const reader = response.body.getReader();
              const chunks = [];
              let received = 0;

              function read() {
                return reader.read().then(({ done, value }) => {
                  if (done) {
                    const blob = new Blob(chunks);
                    return caches
                      .open(build2UnityCacheKey)
                      .then((cache) => {
                        cache.put(contentToCache[idx], new Response(blob));
                      })
                      .then(() => {
                        completedFiles++;
                        if (completedFiles === build2Files.length) {
                          console.log(
                            "âœ… All build2 files downloaded & cached."
                          );
                          safeSendMessage(
                            "Code",
                            "DownloadComplete",
                            build2URL
                          );
                        }
                      });
                  }
                  received += value.length;
                  loadedBytes[idx] = received;
                  chunks.push(value);

                  const percent = Math.round(
                    (loadedBytes.reduce((a, b) => a + b, 0) /
                      totalBytes.reduce((a, b) => a + b, 0)) *
                      100
                  );

                  safeSendMessage("Code", "UpdateFill", percent.toString());
                  return read();
                });
              }

              return read();
            })
            .catch((err) => {
              console.error(`Error caching ${url}:`, err);
            });
        });
      }

      console.log(
        "ðŸŽ® Always starting build1 â€” caching handled by build2 itself."
      );
      initBuild1();

      function dropAll() {
        // ðŸ—‘ï¸ wipe the browser CacheStorage
        caches
          .delete(build2UnityCacheKey)
          .then((success) => {
            if (success) {
              console.log(`ðŸ—‘ï¸ build2 cache "${build2UnityCacheKey}" deleted.`);
            } else {
              console.warn(
                `âš ï¸ build2 cache "${build2UnityCacheKey}" not found.`
              );
            }
          })
          .catch((err) => {
            console.error("Error deleting build2 cache: ", err);
          });

        // ðŸ§¹ wipe blobs in memory
        if (loadedBytes && loadedBytes.length) {
          loadedBytes = [];
        }
        if (totalBytes && totalBytes.length) {
          totalBytes = [];
        }
        completedFiles = 0;

        console.log("ðŸ§¹ in-memory blobs and counters cleared.");
      }
    </script>
  </body>
</html>
